# Dotnet On Heroku: 
[Heroku](www.heroku.com) offers no native support (as of yet) for .NET applications. This is my process for how I deployed [WishList](https://wishlist-bytes.herokuapp.com/) to Heroku. Thankfully the set up is not all that complex and there are tons of third party buildpacks that allow .NET to run on Heroku.

## Initial Setup: 
- Create your app on Heroku, as you would with any other app. You do not have to have a code base for this yet.   
- Once your app is provisioned; GoTo the heroku settings page for your new app. There you will see buildpacks just underneath Config Vars
    - Click Add Buildpack and point it to: `https://github.com/jincod/dotnetcore-buildpack`  
- This is all you need for a basic .NET setup, you can now deploy your code to this dyno via the Heroku CLI or web interface. 

---
## Caveats: 
## Entity Framework Core Migrations

You cannot run migrations with the `dotnet ef` commands using **.NET Local Tools** once the app is built. Alternatives include:

### Enabling Automatic Migrations

- Ensure the `ASPNETCORE_ENVIRONMENT` environment variable is set to `Production`. ASP.NET Core scaffolding tools may create files that explicitly set it to `Development`. Heroku config will override this (`heroku config:set ASPNETCORE_ENVIRONMENT=Production`).
- Configure your app to automatically run migrations at startup by adding the following to the `.csproj` file:

```xml
<Target Name="PrePublishTarget" AfterTargets="Publish">
  <Exec Command="dotnet ef database update" />
</Target>
```

- Configure your connection string string appropriately, for example, for PostgreSQL:

`sslmode=Prefer;Trust Server Certificate=true`

### Manually Running Migration Scripts on the Database

- Manually run SQL scripts generated by Entity Framework Core in your app's database. For example, use PG Admin to connect your Heroku Postgres service.
---

## .NET with Selenium on Heroku: 
Selenium on heroku is no straight forward task. There are two additional buildpacks, both offered by Heroku that we'll need to be added to the dyno for it to work. The first buildpack downloads and installs Google Chrome to they Dyno, the second grabs the chromedriver.    
1. [https://github.com/heroku/heroku-buildpack-google-chrome](https://github.com/heroku/heroku-buildpack-google-chrome)
2. [https://github.com/heroku/heroku-buildpack-chromedriver](https://github.com/heroku/heroku-buildpack-chromedriver)



### Google Chrome Command Line Flags

The Google Chrome buildpack installs shims that always add `--headless`, `--disable-gpu`, 
`--no-sandbox`, and `--remote-debugging-port=9222` to any `google-chrome` 
command as you'll have trouble running Chrome on a Heroku dyno otherwise.

You'll have two of these shims on your path: `google-chrome` and
`google-chrome-$GOOGLE_CHROME_CHANNEL`. They both point to the binary of
the selected channel.

### Selenium-ChromeDriver

To use Selenium with this buildpack, you'll also need Chrome's webdriver.
This buildpack does not install chromedriver, but there is a
[chromedriver buildpack](https://github.com/heroku/heroku-buildpack-chromedriver)
also available.

Additionally, chromedriver expects Chrome to be installed at `/usr/bin/google-chrome`,
but that's a read-only filesystem in a Heroku slug. You'll need to tell Selenium/chromedriver
that the chrome binary is at `/app/.apt/usr/bin/google-chrome` instead.

To make that easier, this buildpack makes `$GOOGLE_CHROME_BIN`, and
`$GOOGLE_CHROME_SHIM` available as environment variables. With them, you can 
use the standard location locally and the custom location on Heroku.


## Running Selenium: 
By default, my $PATH for Selenium looks as follows: 
`CHROMEDRIVER_PATH`:` /app/.chromedriver/bin/chromedriver`
`GOOGLE_CHROME_BIN`:`/app/.apt/usr/bin/google-chrome`

In the development enviroment (my local enviroment) I would keep chromedriver.exe within the root project directory and call upon it as follows: 
```csharp
 public ChromeDriver createBrowser()
        {
            var options = new ChromeOptions();
            options.AddArguments("whitelisted-ips=''", "headless");
            ChromeDriver browser = new ChromeDriver("./", options);
            //give pages 30 seconds to respond before timeing out: 
            browser.Manage().Timeouts().ImplicitWait = TimeSpan.FromSeconds(30);
            return browser;
        }
```

Selenium likes to append '/chromedriver' to the path that is manually specified. So when launched to Heroku; despite chromedriver.exe being located in the root project directory Selenium would still return `OpenQA.Selenium.DriverServiceNotFoundException: The file ./chromedriver does not exist. The driver can be downloaded at http://chromedriver.storage.googleapis.com/index.html` 

I was not able to manually specify the path to chromedriver without Selenium adding '/chromedriver' every time. On Windows Machines this should work just fine, however for a Linux install the chromedriver is labeled as '.chromedriver' making it hidden by default. Trying to call it with `ChromeDriver browser = new ChromeDriver("./.chromedriver", options);` still shows: The file ./.chromedriver/chromedriver doesn't exist. Thankfully however the fix for this is really simple: we just need to let Selenium use PATH instead of passing it the argument. So instead we write: 
```csharp
 public ChromeDriver createBrowser()
        {
            var options = new ChromeOptions();
            options.AddArguments("whitelisted-ips=''", "headless");
            ChromeDriver browser = new ChromeDriver(options); //This forces Selenium to use System PATH
            //give pages 30 seconds to respond before timeing out: 
            browser.Manage().Timeouts().ImplicitWait = TimeSpan.FromSeconds(30);
            return browser;
        } 
```

Success! Selenium should now be able to run both locally and on Heroku!